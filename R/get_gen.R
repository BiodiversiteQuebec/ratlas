library(doParallel)
library(foreach)

SCHEMA_VALUES <- c("public", "api")

#' Generic function to access data from Atlas databases
#'
#' Returns Atlas data objects stored within the database.
#' Queried data objects are obtained through endpoints corresponding to the name
#' of the database object storing the required data
#' (ie. taxa, observations, datasets, etc).
#'
#' This function is designed to interface with a web API deployed with PostgREST
#'
#' @param endpoint `character`. Name of the atlas data object to be accessed.
#' Corresponds to the name of a table, view or stored procedure within Atlas
#' Postgresql database, stored within schema `public` ou `api`
#' @param ... `character` or `numeric` scalar or vector.
#' Additional parameters to filter the returned objects. Accepts
#' parameters corresponding to an object attribute or table columns
#' (ie. `id = c(3,4)`) or a specific parameters related to postgrest http
#' request parameters and syntax(`select = ...`)
#' @param .schema `character` Schema from the database where is located the data
#' object is located. Accept either values `api` or `public` (default)
#' @param .page_limit `integer` Count of objects returned through pagination
#' @param .token  `character` Bearer token providing access to the web api
#' @param .cores `integer` default `4`. Number of cores used to parallelize and
#' improve rapidity
#' @return `tibble` with rows associated with Atlas data object
#' @examples
#' # Returns all available taxa records in atlas
#' taxa <- get_gen("taxa")
#'
#' # Returns all taxa filtered by the column id values
#' taxa <- get_gen("taxa", id = c(188, 201, 294, 392))
#'
#' # Returns first 100 sampling_points from schema `api`
#' sampling_points <- get_gen(
#'  "bird_sampling_points",
#'  .schema = 'api',
#'  limit = 100)
#'
#' # Returns first 100 observations with selected columns and joined columns
#' get_gen('observations',
#'  limit=100,
#'  select='geom,year_obs,month_obs,day_obs,obs_value,taxa(scientific_name)')
#' @export

get_gen <- function(
  endpoint,
  ...,
  .page_limit = 10000,
  .schema = "public",
  .token = ATLAS_API_TOKEN,
  .cores = 4) {

  # Argument validation
  if (! .schema %in% SCHEMA_VALUES) {
    stop("Bad input: Unexpected value for argument `.schema`")
  }

  # Prepare HTTP request with url, header abd query parameters
  url <- httr::modify_url(ATLAS_API_V2_HOST,
    path = paste(httr::parse_url(ATLAS_API_V2_HOST)$path, endpoint, sep = "/"))
  query <- postgrest_query_filter(list(...))
  header <- list(
    Authorization = paste("Bearer", .token),
    `User-Agent` = USER_AGENT, # defined in zzz.R
    Prefer = "count=planned" # header parameter from postgrest
  )
  if (.schema != "public") {
    header$`Accept-Profile` <- .schema
  }

  # Get data through pagination (or not)
  n_pages <- ceiling(endpoint_range_count(url, header) / .page_limit)
  do_pagination <- ! "limit" %in% names(query) & n_pages > 1

  if (do_pagination) {
    registerDoParallel(cores = min(.cores, n_pages))
    responses <- foreach(
      page = 1:n_pages,
      .combine = list,
      .export = "postgrest_get_page"
      ) %dopar% postgrest_get_page(url, header, query, page, .page_limit)
    stopImplicitCluster()
    # responses <- list()
    # for (page in 1:n_pages) {
    #   response <- postgrest_get_page(url, header, query, page, .page_limit)
    #   responses <- list(responses, response)
    # }
    # print(paste0("Time download : ", (proc.time() - tic)[3])) 
    # tic <- proc.time()
    out <- list()
    tmp_responses <- list()
    for (i in 1:n_pages) {
      if (i < n_pages) {
        response <- responses[[2]]
        responses <- responses[[1]]
      } else {
        response <- responses
      }
      postgrest_stop_if_err(response)
      out <- rbind(out, postgrest_resp_to_data(response))
    }
    # print(paste0("Time bind : ", (proc.time() - tic)[3])) 

  } else {
    response <- postgrest_get(url, header, query)
    postgrest_stop_if_err(response)
    out <- postgrest_resp_to_data(response)
  }

  return(out)
}

## Set memoise httr::GET
mem_get <- memoise::memoise(httr::GET)

#' Clear memoise cache

#' @details
#' Clear memoise cache generated by `mem_get()`, a memoise function around
#' [httr::GET()] used in `get_gen` in `get_singleton`
#' @export
clear_cache_ratlas <- function() memoise::forget(mem_get)

endpoint_range_count <- function(url, header) {
  response <- postgrest_get(url, header, query = list(limit = 1))
  postgrest_stop_if_err(response)
  tmp <- unlist(strsplit(httr::headers(response)$"content-range", split = "\\D"))
  range_count <- as.numeric(tmp[grepl("\\d", tmp)])[3L]
  return(range_count)
}

POSTGREST_QUERY_PARAMETERS = c(
  "select", "limit", "offset"
)

postgrest_query_filter <- function(parameters) {
  for (name in names(parameters)) {
    if (name %in% POSTGREST_QUERY_PARAMETERS) {
      next
    }
    if (length(parameters[[name]]) > 1) {
      v_array <- paste0(parameters[[name]], collapse = ",")
      parameters[[name]] <- paste0("in.(", v_array, ")", sep = "")
    } else {
      parameters[[name]] <-  paste0("eq.", parameters[[name]], sep = "")
    }
  }
  return(parameters)
}

postgrest_stop_if_err <- function(response) {
    if (httr::http_error(response)) {
    stop(httr::message_for_status(response, httr::content(response)$message))
  }
}

postgrest_get <- function(url, header, query) {
  response <- httr::GET(url,
                  config = do.call(httr::add_headers, header),
                  query = query)
  return(response)
}

postgrest_resp_to_data <- function(response) {
  textresp <- httr::content(response, type = "text", encoding = "UTF-8")
  df_from_json <- jsonlite::fromJSON(
  textresp, flatten = TRUE, simplifyDataFrame = TRUE)
  data <- tibble::as_tibble(df_from_json)
  return(data)
}

postgrest_get_page <- function(url, header, query, page, limit) {
  offset <- (page - 1) * limit
  query$limit <- format(limit, scientific = FALSE)
  query$offset <- format(offset, scientific = FALSE)

  response <- httr::GET(url,
                  config = do.call(httr::add_headers, header),
                  query = query)
  return(response)
}