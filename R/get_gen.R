SCHEMA_VALUES <- c("public", "api")
DEFAULT_PAGE_PARAMETERS <- list(limit = "limit", offset = "offset")

#' Generic function to access data from Atlas databases
#'
#' Returns Atlas data objects stored within the database.
#' Queried data objects are obtained through endpoints corresponding to the name
#' of the database object storing the required data
#' (ie. taxa, observations, datasets, etc).
#'
#' This function is designed to interface with a web API deployed with PostgREST
#'
#' @param endpoint `character`. Name of the atlas data object to be accessed.
#' Corresponds to the name of a table, view or stored procedure within Atlas
#' Postgresql database, stored within schema `public` ou `api`
#' @param ... `character` or `numeric` scalar or vector.
#' Additional parameters to filter the returned objects. Accepts
#' parameters corresponding to an object attribute or table columns
#' (ie. `id = c(3,4)`) or a specific parameters related to postgrest http
#' request parameters and syntax(`select = ...`)
#' @param .schema `character` Schema from the database where is located the data
#' object is located. Accept either values `api` or `public` (default)
#' @param .page_limit `integer` Count of objects returned through pagination
#' @param .token  `character` Bearer token providing access to the web api
#' @param .cores `integer` default `4`. Number of cores used to parallelize and
#' improve rapidity
#' @param .page_parameters `list` default
#'  `list(limit = "limit", offset = "offset")`. Parameters names sent to http
#'  query to be consumed by the endpoint for pagination
#' @param ..n_pages `integer` default NULL. Estimated if none provided
#' @return `tibble` with rows associated with Atlas data object
#' @examples
#' # Returns all available taxa records in atlas
#' taxa <- get_gen("taxa")
#'
#' # Returns all taxa filtered by the column id values
#' taxa <- get_gen("taxa", id = c(188, 201, 294, 392))
#'
#' # Returns first 100 sampling_points from schema `api`
#' sampling_points <- get_gen(
#'   "bird_sampling_points",
#'   .schema = "api",
#'   limit = 100
#' )
#'
#' # Returns first 100 observations with selected columns and joined columns
#' get_gen("observations",
#'   limit = 100,
#'   select = "geom,year_obs,month_obs,day_obs,obs_value,taxa(scientific_name)"
#' )
#' @importFrom foreach %dopar%
#' @export

get_gen <- function(endpoint,
                    ...,
                    .page_limit = 500000,
                    .schema = "public",
                    .cores = 4,
                    .page_parameters = DEFAULT_PAGE_PARAMETERS,
                    .n_pages = NA) {

  # Argument validation
  if (!.schema %in% SCHEMA_VALUES) {
    stop("Bad input: Unexpected value for argument `.schema`")
  }

  # Prepare HTTP request with url, header abd query parameters

  # Postgrest query value filter format if not stored procedure
  is_function <- grepl("rpc", endpoint)
  if (! is_function) {
    query <- postgrest_query_filter(list(...))
  } else {
    query <- list(...)
  }

  # Get data through pagination (or not)
  if (is.na(.n_pages)) {
    if (! "limit" %in% names(query) & ! is_function) {
    .n_pages <- ceiling(
      endpoint_range_count(endpoint, query, .schema) / .page_limit)
    } else {
      .n_pages <- 1
    }
  }
  .cores <- min(.cores, .n_pages)

  debug <- as.logical(Sys.getenv("DEBUG"))
  if (is.na(debug)) debug <- FALSE

  if (.n_pages > 1) {
    if (debug) {
      out <- list()
      for (page in 1:.n_pages) {
        response <- postgrest_get_page(
          endpoint, query,
          page, .page_limit, .schema, .page_parameters
        )
        postgrest_stop_if_err(response)
        out <- rbind(out, postgrest_resp_to_data(response))
      }
    } else {
      doParallel::registerDoParallel(cores = .cores)
      on.exit(doParallel::stopImplicitCluster())
      out <- foreach::foreach(
        page = 1:.n_pages,
        .combine = rbind,
        .export = c(
          "postgrest_get_page",
          "postgrest_stop_if_err",
          "postgrest_resp_to_data",
          ".page_parameters"
        )
      ) %dopar% {
        response <- postgrest_get_page(
          endpoint, query,
          page, .page_limit, .schema, .page_parameters
        )
        postgrest_stop_if_err(response)
        postgrest_resp_to_data(response)
      }
    }
  } else {
    response <- postgrest_get(endpoint, query, .schema)
    postgrest_stop_if_err(response)
    out <- postgrest_resp_to_data(response)
  }
  return(out)
}

## Set memoise httr::GET
mem_get <- memoise::memoise(httr::GET)

#' Clear memoise cache

#' @details
#' Clear memoise cache generated by `mem_get()`, a memoise function around
#' [httr::GET()] used in `get_gen` in `get_singleton`
#' @export
clear_cache_ratlas <- function() memoise::forget(mem_get)

endpoint_request_param <- function(
    endpoint,
    .schema = "public") {
  url <- httr::modify_url(ATLAS_API_V2_HOST(),
    path = paste(httr::parse_url(ATLAS_API_V2_HOST())$path, endpoint, sep = "/")
  )
  header <- list(
    Authorization = paste("Bearer", ATLAS_API_TOKEN()),
    `User-Agent` = USER_AGENT(), # defined in zzz.R
    Prefer = "count=planned", # header parameter from postgrest
    `Accept-Profile` = .schema
  )
  return(
    list(
      url = url,
      header = header
    )
  )
}

endpoint_range_count <- function(
    endpoint,
    query = NULL,
    .schema = "public") {
  if (is.null(query)){
    query <- list()
  }
  query$limit <- 1
  response <- postgrest_get(endpoint, query, .schema)
  postgrest_stop_if_err(response)
  tmp <- unlist(
      strsplit(httr::headers(response)$"content-range", split = "\\D")
    )
  range_count <- as.numeric(tmp[3])
  return(range_count)
}

POSTGREST_QUERY_PARAMETERS <- c(
  "select", "limit", "offset"
)

postgrest_query_filter <- function(parameters) {
  for (name in names(parameters)) {
    if (name %in% POSTGREST_QUERY_PARAMETERS) {
      next
    }
    if (length(parameters[[name]]) > 1) {
      v_array <- paste0(parameters[[name]], collapse = ",")
      parameters[[name]] <- paste0("in.(", v_array, ")", sep = "")
    } else {
      parameters[[name]] <- paste0("eq.", parameters[[name]], sep = "")
    }
  }
  return(parameters)
}

postgrest_stop_if_err <- function(response) {
  if (httr::http_error(response)) {
    stop(httr::message_for_status(response, httr::content(response)$message))
  }
}

postgrest_get <- function(
  endpoint,
  query,
  .schema = "public") {
  request_param <- endpoint_request_param(endpoint, .schema)
  for (name in names(query)) {
    if (is.numeric(query[[name]])) {
      query[[name]] <- format(query[[name]], scientific = FALSE)
    }
  }
  response <- httr::GET(request_param$url,
    config = do.call(httr::add_headers, request_param$header),
    query = query
  )
  return(response)
}

postgrest_resp_to_data <- function(response) {
  textresp <- httr::content(response, type = "text", encoding = "UTF-8")
  df_from_json <- jsonlite::fromJSON(
    textresp,
    flatten = TRUE, simplifyDataFrame = TRUE
  )
  data <- tibble::as_tibble(df_from_json)
  return(data)
}

postgrest_get_page <- function(
    endpoint,
    query,
    page,
    limit,
    .schema = "public",
    .page_parameters = DEFAULT_PAGE_PARAMETERS) {
  url <- httr::modify_url(ATLAS_API_V2_HOST(),
    path = paste(httr::parse_url(ATLAS_API_V2_HOST())$path, endpoint, sep = "/")
  )
  header <- list(
    Authorization = paste("Bearer", ATLAS_API_TOKEN()),
    `User-Agent` = USER_AGENT(),
    `Accept-Profile` = .schema
  )
  offset <- (page - 1) * limit
  query[.page_parameters$limit] <- format(limit, scientific = FALSE)
  query[.page_parameters$offset] <- format(offset, scientific = FALSE)

  response <- httr::GET(url,
    config = do.call(httr::add_headers, header),
    query = query
  )
  return(response)
}