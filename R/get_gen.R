#' Fonction générique pour retirer de l'information depuis l'API de Coléo
#'
#' @param endpoint `character` désignant le point d'entrée pour le retrait
#' des données. Un point d'entrée peut être vu comme une table de la base
#' de données.
#' @param ... Paramètres de la requête url
#' @param .schema Schema de la base de données où se situe la table. Options
#' disponibles : `api` ou `public` (par défaut)
#' @param .page_count count of objects returned through pagination
#' @param .token  `character` jeton d'accès pour authentification auprès de l'API
#' @return
#' Retourne un objet de type `list` contenant les réponses de l'API. Chaque
#' niveau de la liste correspond à une page. Pour chacun des appels sur l'API
#' (page), la classe retourné est `getSuccess` ou `getError`. Une réponse de
#' classe `getSuccess` est une liste à deux niveaux composé du contenu (`body`),
#' et la réponse [httr::response]. Une réponse de classe `getError` dispose de
#' la même structure mais ne contiendra pas de body, seulement la réponse de
#' l'API.
#' @details
#' Les points d'accès de l'API sont énuméré dans l'environment de atlas, voir
#' `print(endpoints)`
#' @examples
#' \dontrun{
#' resp <- get_gen("/taxa")
#' length(resp) # Nombre de pages retourné par l'appel sur le point d'accès de l'API.
#' str(resp[[1]])
#' }
#' @export

SCHEMA_VALUES <- c("public", "api")

get_gen <- function(
  endpoint,
  .page_count = 200000,
  .schema = "public",
  .token = ATLAS_API_TOKEN, ...) {

  # Argument validation
  if (! .schema %in% SCHEMA_VALUES) {
    stop("Bad input: Unexpected value for argument `.schema`")
  }

  # PREPARE HTTP REQUEST

  url <- httr::modify_url(ATLAS_API_V2_HOST, path = paste0(endpoint))
  query <- list(...)


  # Add pagination parameters
  pagination_break <- "limit" %in% names(query)
  offset <- 0
  if (! pagination_break) {
    query$limit <- format(.page_count, scientific = FALSE)
    query$offset <- format(offset, scientific = FALSE)
  }

  header <- list(
    Authorization = paste("Bearer", .token),
    `User-Agent` = USER_AGENT # defined in zzz.R
  )

  # Add the .schema
  if (.schema != "public") {
    header$`Accept-Profile` <- .schema
  }
  out <- list()
  while (TRUE) {
    resp <- mem_get(url,
                    config = do.call(httr::add_headers, header),
                    query = query)

    if (! httr::status_code(resp) == 200) {
      stop(httr::message_for_status(resp))
    }
    rows <- resp_df(resp)
    n_rows <- nrow(rows)
    out <- rbind(out, rows)

    pagination_break <- pagination_break |
      n_rows == 0 |
      n_rows %% .page_count != 0
    if (pagination_break) {
      break
      }

    offset <- offset + n_rows
    query$offset <- format(offset, scientific = FALSE)
  }

  return(out)
}

## Set memoise httr::GET
mem_get <- memoise::memoise(httr::GET)

#' Clear memoise cache

#' @details
#' Clear memoise cache generated by `mem_get()`, a memoise function around
#' [httr::GET()] used in `get_gen` in `get_singleton`
#' @export
clear_cache_ratlas <- function() memoise::forget(mem_get)

resp_df <- function(x){
  textresp <- httr::content(x, type = "text", encoding = "UTF-8")
  df_from_json <- jsonlite::fromJSON(textresp, flatten = TRUE, simplifyDataFrame = TRUE)
  tibble::as_tibble(df_from_json)

}