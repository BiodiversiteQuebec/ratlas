SCHEMA_VALUES <- c("public", "api")

#' Generic function to access data from Atlas databases
#'
#' Returns Atlas data objects stored within the database.
#' Queried data objects are obtained through endpoints corresponding to the name
#' of the database object storing the required data
#' (ie. taxa, observations, datasets, etc).
#'
#' This function is designed to interface with a web API deployed with PostgREST
#'
#' @param endpoint `character`. Name of the atlas data object to be accessed.
#' Corresponds to the name of a table, view or stored procedure within Atlas
#' Postgresql database, stored within schema `public` ou `api`
#' @param ... `character` or `numeric` scalar or vector.
#' Additional parameters to filter the returned objects. Accepts
#' parameters corresponding to an object attribute or table columns
#' (ie. `id = c(3,4)`) or a specific parameters related to postgrest http
#' request parameters and syntax(`select = ...`)
#' @param .schema `character` Schema from the database where is located the data
#' object is located. Accept either values `api` or `public` (default)
#' @param .page_count `integer` Count of objects returned through pagination
#' @param .token  `character` Bearer token providing access to the web api
#' @return `tibble` with rows associated with Atlas data object
#' @examples
#' # Returns all available taxa records in atlas
#' taxa <- get_gen("taxa")
#'
#' # Returns all taxa filtered by the column id values
#' taxa <- get_gen("taxa", id = c(188, 201, 294, 392))
#'
#' # Returns first 100 sampling_points from schema `api`
#' sampling_points <- get_gen(
#'  "bird_sampling_points",
#'  .schema = 'api',
#'  limit = 100)
#'
#' # Returns first 100 observations with selected columns and joined columns
#' get_gen('observations',
#'  limit=100,
#'  select='geom,year_obs,month_obs,day_obs,obs_value,taxa(scientific_name)')
#' @export

get_gen <- function(
  endpoint,
  .page_count = 10000,
  .schema = "public",
  .token = ATLAS_API_TOKEN,
  ...) {

  # Argument validation
  if (! .schema %in% SCHEMA_VALUES) {
    stop("Bad input: Unexpected value for argument `.schema`")
  }

  # PREPARE HTTP REQUEST
  url <- httr::modify_url(ATLAS_API_V2_HOST,
    path = paste(httr::parse_url(ATLAS_API_V2_HOST)$path, endpoint, sep = "/"))
  query <- postgrest_filter(list(...))


  # Add pagination parameters
  pagination_break <- "limit" %in% names(query)
  offset <- 0
  if (! pagination_break) {
    query$limit <- format(.page_count, scientific = FALSE)
    query$offset <- format(offset, scientific = FALSE)
  }

  header <- list(
    Authorization = paste("Bearer", .token),
    `User-Agent` = USER_AGENT # defined in zzz.R
  )

  # Add the .schema
  if (.schema != "public") {
    header$`Accept-Profile` <- .schema
  }
  out <- list()
  while (TRUE) {
    resp <- httr::GET(url,
                    config = do.call(httr::add_headers, header),
                    query = query)

    if (! httr::status_code(resp) == 200) {
      stop(httr::message_for_status(resp, httr::content(resp)$message))
    }
    rows <- resp_df(resp)
    n_rows <- nrow(rows)
    out <- rbind(out, rows)

    pagination_break <- pagination_break |
      n_rows == 0 |
      n_rows %% .page_count != 0
    if (pagination_break) {
      break
      }

    offset <- offset + n_rows
    query$offset <- format(offset, scientific = FALSE)
  }

  return(out)
}

## Set memoise httr::GET
mem_get <- memoise::memoise(httr::GET)

#' Clear memoise cache

#' @details
#' Clear memoise cache generated by `mem_get()`, a memoise function around
#' [httr::GET()] used in `get_gen` in `get_singleton`
#' @export
clear_cache_ratlas <- function() memoise::forget(mem_get)

resp_df <- function(x) {
  textresp <- httr::content(x, type = "text", encoding = "UTF-8")
  df_from_json <- jsonlite::fromJSON(
    textresp, flatten = TRUE, simplifyDataFrame = TRUE)
  tibble::as_tibble(df_from_json)

}

POSTGREST_QUERY_PARAMETERS = c(
  "select", "limit", "offset"
)

postgrest_filter <- function(parameters) {
  for (name in names(parameters)) {
    if (name %in% POSTGREST_QUERY_PARAMETERS) {
      next
    }
    if (length(parameters[[name]]) > 1) {
      v_array <- paste0(parameters[[name]], collapse = ",")
      parameters[[name]] <- paste0("in.(", v_array, ")", sep = "")
    } else {
      parameters[[name]] <-  paste0("eq.", parameters[[name]], sep = "")
    }
  }
  return(parameters)
}